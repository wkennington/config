#!/usr/bin/env sh

# Exports extra params
agent_export () {
  export SSH_AUTH_SOCK
  export GPG_AGENT_INFO
  export GNOME_KEYRING_CONTROL
  export GNOME_KEYRING_PID
}

# Retrieve the agent environment
agent_file () {
  echo "$(dir_tmp)/agent-environment"
}

# Retrieve the file where the agent command is written
agent_cmd_file() {
  echo "$(dir_tmp)/agent-cmd"
}

# Print cmd if agent exists
agent_cmd () {
  [ "$#" -lt "1" ] && return 1
  path_hasbin $1 && echo "$@ ;"
}

# Find a specific pcsc driver
agent_find_pcsc_lib () {
  VAL="$(find "$1" -name libpcsclite.so\* 2>/dev/null | head -n 1)"
  [ -z "$VAL" ] && return 1
  echo "$VAL"
  exit 0
}

# Find the path to the pcsc driver
agent_find_pcsc () {
  agent_find_pcsc_lib "/run/current-system/sw/lib/"
  agent_find_pcsc_lib "$HOME/.nix-profile/lib/"
  agent_find_pcsc_lib "/usr/local/lib/"
  agent_find_pcsc_lib "/usr/lib64/"
  agent_find_pcsc_lib "/lib64/"
  agent_find_pcsc_lib "/usr/lib/"
  agent_find_pcsc_lib "/lib/"
  exit 1
}

agent_pin_program_check () {
  local PIN="$(path_bin "$1")"
  $PIN </dev/null >/dev/null 2>&1 || return 1
  echo $PIN
}

# Find the path to the pinentry application
agent_pin_program () {
  agent_pin_program_check pinentry && return 0
  agent_pin_program_check pinentry-curses && return 0
  return 1
}

# Prints the command for running the gpg-agent
agent_gpg () {
  mkdir -p "$HOME/.gnupg"
  echo "pcsc-driver $(agent_find_pcsc)" > "$HOME/.gnupg/scdaemon.conf"
  echo "card-timeout 5" >> "$HOME/.gnupg/scdaemon.conf"
  echo "disable-ccid" >> "$HOME/.gnupg/scdaemon.conf"
  local PIN_PROG;
  PIN_PROG="$(agent_pin_program)"
  if [ "$?" -ne "0" ]; then
    echo "Couldn't select gpg-agent: no pinentry program" >&2
  else
    agent_cmd gpg-agent --pinentry-program "\"$PIN_PROG\"" --daemon --enable-ssh-support && return 0
  fi
  return 1
}

# Prints the command for running the ssh-agent
agent_ssh () {
  agent_cmd ssh-agent
}

# Determine which agent to use
agent_which () {
  [ "$1" = "ssh" ] && agent_ssh && return 0
  [ "$1" = "gpg" ] && agent_gpg && return 0
  hostname | grep -q 'corp.google.com$' && agent_cmd /usr/bin/ssh-agent && return 0
  (info_ws && ! info_root) && agent_gpg && return 0
  agent_ssh && return 0
  echo "Failed to find an agent" >&2
  return 1
}

# Tests to see if the agent is already running
agent_running () {
  run_quiet ssh-add -L
  [ "$?" -ne "2" ]
}

# Make sure that the running agent is the proper one
agent_proper () {
  if agent_running; then
    if [ ! -e "$(agent_cmd_file)" ]; then
      killall ssh-agent
      killall gpg-agent
      unset SSH_AGENT_PID
      unset SSH_AUTH_SOCK
    else
      OLD="$(cat "$(agent_cmd_file)" 2>/dev/null | awk '{print $1}' | xargs basename 2>/dev/null)"
      NEW="$(echo "$AGENT_CMD" | awk '{print $1}' | xargs basename)"
      if [ -n "$OLD" ] && [ "$OLD" != "$NEW" ]; then
        PIDS="$(ps ux | grep "$OLD" | awk '{print $2}')"
        for PID in $PIDS; do
          kill $PIDS
        done
        unset SSH_AGENT_PID
        unset SSH_AUTH_SOCK
      fi
    fi
  fi
}

# Import already running agent data
agent_env () {
  [ -f "$(agent_file)" ] && . "$(agent_file)"
  if [ -n "$AGENT_EXTRA_ENV" ]; then
    eval $AGENT_EXTRA_ENV
  fi
  agent_export
  agent_running
}

# Spawn agent if it doesn't exist
agent_spawn () {
  echo "Spawning $@"
  echo "$@" > "$(agent_cmd_file)"
  (eval "$@") | grep -v echo > "$(agent_file)"
  agent_env
  ssh-add
}

# Automatically determines which agent to use and starts it if necessary
agent_auto () {
  local AGENT_CMD;
  AGENT_CMD=$(agent_which $AGENT)
  agent_proper
  if ! agent_running; then
    agent_env
  fi
  agent_proper
  if ! agent_running; then
    agent_spawn $AGENT_CMD
  fi
  agent_proper
  agent_running
}
